"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

############ define protocol parameters ############ 
LENGTH = 2000    # packet length (change for different tx rates)

# ib: SEQ changes below, so it is not a constant. Don't use CAPS if the variable is not constant.

SEQ = 1          # sequence number of packets, starting from 1
WIN = 10     # check packet loss every WIN ack
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
              

def getlocalipport():
# ib: missing function comment -- why not just define the tuple at top-level without a fn?
  localip = getmyip()
  localport = 63100
  return (localip, localport)


def getdestipport():
# ib: missing function comment -- why not just define the tuple at top-level without a fn?
  destip = getmyip()  # TODO: this needs to be a phone's IP
  destport = 63101
  return (destip, destport)


def translatemessage(message):
# ib: missing function comment -- deserialize might be a better name for this.
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of passed in RTT values.
  """
  return max(recentobservedRTTs)


def recvack(routerlistensocket, sequence, recentobservedRTTs):
# ib: missing function comment
# ib: sequence is poor var name -- sequence of what?

  def ack(): 
#ib: missing function comment
    while True:
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        recvtime = getruntime()
        (seq, move) = translatemessage(message)  # TODO: use movement info
             
        if int(seq) in sequence:  
          # delete seq upon ack
          sendtime = sequence[int(seq)]
          del sequence[int(seq)]
          rtt = recvtime - sendtime

          # ib: since you use if DEBUG == 1: log(blah) multiple times,
          # refactor this into a method like logifdebug(blah)
          if DEBUG == 1:
            log(seq + "th pkt received. send time: " + str(sendtime) + 
                "  receive time: " + str(recvtime) + "  rtt: " + str(rtt) 
                + ". seq queue: " + str(sequence) + "\n") 

          recentobservedRTTs.append(rtt)
          if len(recentobservedRTTs) > WIN: 

            # ib: pop(0) doesn't really update the RTT -- it just
            # removes an old RTT from the list..

            # update RTT for every WIN packets
            recentobservedRTTs.pop(0)

          if DEBUG == 1:
            log("recentobservedRTTs: " + str(recentobservedRTTs) + "\n\n")
            
        else:
          log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n")                

      except SocketWouldBlockError:
        pass

  return ack


def checkRTT(recentobservedRTTs, sequence):
# ib: add comment -- what does this do?
# ib: this needs a better name, something that reflects what this
# done. Like expireSentPackets or the like.

  def rtt():
# ib: add comment -- what does this do?
    while True:
      if len(recentobservedRTTs) < WIN: # need at least WIN pkts
        continue 

      delseq = []
      updatedRTT = estimateRTT(recentobservedRTTs)
      for (id, sendtime) in sequence.items():
# ib: explain this in a comment
        if sendtime < (getruntime() - updatedRTT*2):
          if DEBUG == 1:
            log(str(id) + "th packet too old.. delete\n")
          delseq.append(id)

      for i in delseq:
        try:
          del sequence[i]
        except KeyError:
          # at this point, previously recorded id could already  
          # be deleted by the recvack thread
          log(str(i) + "th not in the sequence (already received?).\n")
          pass

      if DEBUG == 1:
        log("after checkRTT, sequence: " + str(sequence) + "\n")

      sleep(updatedRTT*2)

  return rtt


############ main program ############ 

(localip, localport) = getlocalipport()
(destip, destport) = getdestipport()

# router's socket for client's ack
routerlistensocket = listenformessage(localip, localport)

# initial variables
starttime = getruntime()
sequence = {}
recentobservedRTTs = []  # initially set to a large value
totallen = 0   # record total bytes received
totaltime = 0

# thread that receives acks
# ib: and does what with them?
createthread(recvack(routerlistensocket, sequence, recentobservedRTTs))
# ib: thread that checks RTT..?
createthread(checkRTT(recentobservedRTTs, sequence))

while True: 
  # router sends a bunch of packets to the client
  # ib: '0' is a char, so you are definitely sending bytes, not bits.
  packet = [SEQ, '0'*LENGTH]  
  sequence[SEQ] = getruntime()  # record (seq, sendtime)
  
  if DEBUG == 1:
    log("sending " + str(SEQ) + "th packet. sending sequence: " 
        + str(sequence) + "\n")
  
  sendmessage(destip, destport, str(packet), localip, localport)

# ib: So, you are basically doing stop-and-wait by sleeping below. You
# are waiting for each ack before sending the next packet. This is
# safe (i.e., only one data packet in the pipe at a time), but highly
# inefficient. You want to saturate the pipe by sending a preset
# window of packets in each RTT, and change the window based on
# observed loss.
 
  if recentobservedRTTs != []:
    sleep(estimateRTT(recentobservedRTTs))

  SEQ = SEQ + 1

