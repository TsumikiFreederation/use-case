"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

############ define protocol parameters ############ 
LENGTH = 2000    # packet length (change for different tx rates)
sequenceno = 1   # sequence number of packets, starting from 1
WIN = 10      # check packet loss every WIN ack
DEBUG = 1     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
            

def deserialize(message):
      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):

  """
  Returns the max value of recent RTTs
  """
  return max(recentobservedRTTs)


def logifdebug(DEBUG, string):

  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 
  

def recvack(routerlistensocket, packetsequence, recentobservedRTTs):

  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack(): 
      
    """
    Inside of the closure
    """

    while True:
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        recvtime = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 
             
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          # delete seq upon ack
          try:
            del packetsequence[int(seq)]           
            # if del throws KeyError, the rest from here in the try block will be skipped
            rtt = recvtime - sendtime
            logifdebug(DEBUG, seq + "th pkt received. send time: " + str(sendtime) + 
                "  receive time: " + str(recvtime) + "  rtt: " + str(rtt) 
                + ". seq queue: " + str(packetsequence)) 

            # update RTT
            recentobservedRTTs.append(rtt)
            if len(recentobservedRTTs) > WIN: # only keep WIN most recent RTTs
              recentobservedRTTs.pop(0)

            logifdebug(DEBUG, "recentobservedRTTs: " + str(recentobservedRTTs) + "\n")
              
          except KeyError:
            # at this point, checkRTT thread could delete this packet
            log(seq + "th not in the sequence (already timeout?).\n")
            pass
            
        else:
          log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n")                

      except SocketWouldBlockError:
        pass

  return ack


def expiresentpackets(recentobservedRTTs, packetsequence):

  """
  A closure that checks if a packet in packetsequence has
  timed out.
  """
  
  def rtt():

    """
    Inside of the closure
    """
  
    while True:
      if len(recentobservedRTTs) < WIN: # need at least WIN pkts
        continue 

      delseq = []
      updatedRTT = estimateRTT(recentobservedRTTs)
      for (id, sendtime) in packetsequence.items():
        if sendtime < getruntime() - updatedRTT*2:
          # if a packet was sent more than twice 
          # RTT ago, then it's considered timed out
          logifdebug(DEBUG, str(id) + "th packet too old...need to delete")
          delseq.append(id)

      for i in delseq:
        try:
          del packetsequence[i]
        except KeyError:
          # at this point, previously recorded id could already  
          # be deleted by the recvack thread
          log(str(i) + "th not in the sequence (already received?).\n")
          pass

      logifdebug(DEBUG, "after checkRTT, sequence: " + str(packetsequence))

      sleep(updatedRTT*2)

  return rtt


############ main program ############ 

(localip, localport) = (getmyip(), 63100)
(destip, destport) = (getmyip(), 63101)  # TODO: this needs to be phone's IP

# router's socket for client's ack
routerlistensocket = listenformessage(localip, localport)

# initial variables
starttime = getruntime()
packetsequence = {}
recentobservedRTTs = []  # initially set to a large value
totallen = 0   # record total bytes received
totaltime = 0

# thread that receives ack from the receiver, removes it from 
# packetsequence, and update the recently observed RTT
createthread(recvack(routerlistensocket, packetsequence, recentobservedRTTs))

# thread that checks if a packet in packetsequence has timed out.
createthread(expiresentpackets(recentobservedRTTs, packetsequence))

while True: 
  # router sends a bunch of packets to the client
  packet = str(sequenceno) + "|" + '0'*LENGTH 
  packetsequence[sequenceno] = getruntime()  # record (seq, sendtime)
  
  logifdebug(DEBUG, "sending " + str(sequenceno) + "th packet. sending sequence: " 
    + str(packetsequence))
  
  sendmessage(destip, destport, str(packet), localip, localport)

  # ib: So, you are basically doing stop-and-wait by sleeping below. You
  # are waiting for each ack before sending the next packet. This is
  # safe (i.e., only one data packet in the pipe at a time), but highly
  # inefficient. You want to saturate the pipe by sending a preset
  # window of packets in each RTT, and change the window based on
  # observed loss.
 
  if recentobservedRTTs != []:
    sleep(estimateRTT(recentobservedRTTs))

  sequenceno = sequenceno + 1

