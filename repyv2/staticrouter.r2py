#
# IB: Refactor the repyv2/; particularly move this file out of the repyv2/ directory.
#

"""
<Program Name>
  staticrouter.r2py

<Started>
  Aug 15, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

dy_import_module_symbols("outstandingseq.r2py")
dy_import_module_symbols("routercommon.r2py")  
dy_import_module_symbols('random.r2py') 
  

def ispermanent(seq):
  """
  Return if a packet seq # is temporary (0) or not (1).
  """

  if seq % WINSIZE in PERMWIN:
    return 1
  
  if seq % WINSIZE in TEMPWIN:
    return 0
    

def existconsecutivelosses(seqlist, n):
  """
  Find if there are n consequtive numbers in the lost packet 
  sequence when using rate.
  """
  for i in range(0, n-1):
    if seqlist[i+1] != seqlist[i] + 1:
      return False
    
  return True


def firstsendtime(packetinfo):
  """
  Find first packet in packetinfo that has not been deleted.
  """
  minsequence = min(packetinfo)  # find the smallest key
  return packetinfo[minsequence]



def findcandidate(lostseq, oldrate, num):
  """
  Find candidate rates that are other than oldrate, and have num
  consecutive failures.
  """
  candidate = []
  for t in sleeptime:
    if t!= oldrate:
      if len(lostseq[t]) < num or existconsecutivelosses(lostseq[t], num) == False:
        candidate.append(t)
      
  return candidate



def selectpermrate(lostseq, oldrate):
  """
  Select the highest rate without 4 successive failures if exist.
  Otherwise select the rate with lowest average transmission time.
  """
  selected = None  
  candidate = findcandidate(lostseq, oldrate, 4)
      
  if candidate != []:  # select the highest rate that has no 4 succcessive fails
    currentbitrate[0] = min(candidate)
    log("1.1.1 new sleep time (highest rate with no successive 4 fails): " 
        + str(currentbitrate[0]) + '\n\n')     
       
  else:   # no candidate found: select the rate with lowest avg tx time
    txtime = {}
    for t in sleeptime:
      RTTlist = recentobservedRTTs[t]
      if RTTlist != []:
        avgtxtime = sum(RTTlist)/len(RTTlist)
        log("rate: " + str(t) + " avg txtime: " + str(avgtxtime) + '\n')
        txtime[t] = avgtxtime
      else:
        log("rate: " + str(t) + " avg txtime: 0\n")
        txtime[t] = 0

    minrate = min(txtime, key=txtime.get)   # the rate that has the lowest tx time
    currentbitrate[0] = minrate
    log("1.1.2 no candidate found. new sleep time (rate with lowest tx time): " 
        + str(currentbitrate[0]) + '\n\n')


def selecttemprate(lostseq, oldrate):
  """
  Select a random rate that (1) has not failed n successive times and 
  (2) have a minimum transmission time lower than the currentrate's 
  average transmission time.
  """
  candidate = findcandidate(lostseq, oldrate, 4)
  random_shuffle(candidate)  # random shuffling rates
  
  currentRTTs = recentobservedRTTs[oldrate]
  if currentRTTs != []:
    current_txtime = sum(currentRTTs)/len(currentRTTs)
  else:
    current_txtime = 0
  
  for rate in candidate:
    RTTlist = recentobservedRTTs[rate]
    if RTTlist == []:
      minrate = 0
    else:
      minrate = min(RTTlist)
        
    log("min tx time: among " + str(candidate) + 
          " (has no 4 succcessive fails): " + str(minrate) + '\n')
    if minrate < current_txtime:
      currentbitrate[0] = rate
      break
      
  log("new sleep time: " + str(currentbitrate[0]) + '\n\n')


  
def samplerate(packetinfo, firstid, lastid, lostseq):
  """
  Given lost packets, adjust sending rate. 
  """

  # seq no should be the no. that is the largest no. two RTTs ago, not the current
  # iterate over all no.'s that are <= the no. above
  # for all _seq_ <= the above no.
  rate = currentbitrate[0]
  seq = firstid

  while seq <= lastid: 
    if seq in packetinfo:     
      # if current rate is the rate of the _seq_, and 
      # S consecutive losses (reuse the lostseq 3 id's), let it influence the current rate
      # select perm rate
      if ratefailed[rate] == []:
        seq = seq + 1
        continue 
    
      failed, timefailed = ratefailed[rate]
      rateofseq, sendtime = packetinfo[seq]
      if failed == True and rateofseq == rate:
        log("1.1 successive 4 fails happened at rate " + str(oldrate) + ". ")
        selectpermrate(lostseq, oldrate)
      else:
        log("1.2 fewer than successive 4 fails happened at rate " + str(rate) + "\n\n")
      seq = seq + 1
    
    

def checkloss_static(now, RTT, packetinfo, outstandingseq):
  """
  Every 2*RTT check pkt loss, delete outdated packets.
  """

  timethresh = now - 2*RTT

  # repy does not allow sort!
  packetlist = packetinfo.items()[:]  
  # sort packetinfo by packet seq number
  packetlist.sort()
  lastid = 0   # record the largest packet seq two RTTs ago

  log(str(packetlist) + "\n" + str(timethresh) + "\n")
  
  for (seq, (rate, sendtime)) in packetlist:
    # if a packet was sent more than 2RTT ago and not ack-ed, it's considered lost
    if sendtime < timethresh:
      lostseq[rate].append(seq)  # TODO: diff temp/perm seq's
      lastid = seq
      if len(lostseq[rate]) == NUMLOSS:
        # check if it contains 4 (NUMLOSS) seccesive ids
        if existconsecutivelosses(lostseq[rate], NUMLOSS) == True:
          # remmeber this failure, if threading, grab lock
          ratefailed[rate] = (True, now)
        # delete the first id (even they are not 4 seccesive ids)
        # always keep <= 3 ids
        lostseq[rate].pop(0)
    else:
      break      
  # done checking lost packets for the past 2RTTs 

  firstid = min(packetinfo)
  # possibly change sending rate depending on losses
  log("checking " + str(firstid) + " to " + str(lastid) + 
      '\n' + str(lostseq) + '\n' + str(ratefailed) + '\n')
  samplerate(packetinfo, firstid, lastid, lostseq)

  for rate in sleeptime:
    if lostseq[rate] != []:
      seqlimit = lostseq[rate][-1]  # find the largest seq in lostseq
      numlost = findlessthan(outstandingseq, seqlimit)  
    
      # Remove all numlost from packetinfo
      for seq in numlost:
        #if seq in packetinfo: (this is an optimization)
          try:
            del packetinfo[seq]
          except KeyError:
            # possibily recvack got this seq's ack
            log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
            pass

      # packets older than 2RTT (seq's smaller than seqlimit in 
      # outstandingseq) are considered lost: remove them all 
      removelessthan(outstandingseq, seqlimit)


    
def recvack(routerlistensocket, packetinfo, 
                     recentobservedRTTs, outstandingseq):
  """
  A closure that receives ack from the receiver, removes it from 
  packetinfo, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        # if there is SocketWouldBlockError, the rest will be skipped
        
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        listlock.acquire(True)
        delfromoutstandingseq(int(seq), outstandingseq)
        listlock.release()
      
        if int(seq) in packetinfo:
          rate, sendtime = packetinfo[int(seq)]
          
          try:  # delete seq upon ack
            del packetinfo[int(seq)]           
          except KeyError:
            pass

          newrtt = now - sendtime  # update RTT for each rate
          recentobservedRTTs[rate].append(newrtt)
          if len(recentobservedRTTs[rate]) > RTTWIN: # only keep RTTWIN most recent RTTs
            recentobservedRTTs[rate].pop(0)

      except SocketWouldBlockError:
        pass

  return ack


def sendpackets(sequenceno, packetinfo, outstandingseq):
  """
  Sends packets to the receiver.
  """
  while True:     
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    timestamp = getruntime()  # record (seq, sendtime)
    packetinfo[sequenceno] = (currentbitrate[0], timestamp)
    
    listlock.acquire(True)
    addtooutstandingseq(sequenceno, outstandingseq)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp

    if ispermanent(sequenceno) == 0:
      if temppacketset[0] == 0:
        log("1.0 temp packet " + str(sequenceno) + " at " + str(currentbitrate[0]) + " ")
        selecttemprate(lostseq, currentbitrate[0])
        temppacketset[0] = 1
        
    else:  # permanent packets
      temppacketset[0] = 0
      # based on recently observed RTTs, find/check/remove packets older than 2RTT
      if recentobservedRTTs[currentbitrate[0]] != []:
        RTT = estimateRTT(recentobservedRTTs[currentbitrate[0]])
        if (timestamp - oldestpktsendtime[0]) > 2*RTT:
          listlock.acquire(True)
          checkloss_static(timestamp, RTT, packetinfo, outstandingseq)
          listlock.release()
          oldestrate, oldestpktsendtime[0] = firstsendtime(packetinfo)
    
    sleep(currentbitrate[0])  # sleep for currentbitrate sec
    sequenceno = sequenceno + 1
  

def main():
  """
  The main funciton.
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1
  outstandingseq = []    # record outstanding packets
  packetinfo = {}    # dict of (seq: (rate, sendtime))

  # thread that receives ack from the receiver, removes it from 
  # packetinfo, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetinfo, 
                     recentobservedRTTs, outstandingseq))

  sendpackets(sequenceno, packetinfo, outstandingseq)


############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
DEBUG = 0        # output some debug messages if DEBUG == 1 
RTTWIN = 30      # keep the most recent for RTTWIN packets
NUMLOSS = 4      # if NUMLOSS happened consecutively, change rate  
WINSIZE = 1000     # the last 100 in 1000 are temp packets, others are permanent
PERMWIN = range(1, 900)         # if packet seq falls in this range [1, 900), it's permanent
TEMPWIN = range(900, WINSIZE+1) # if packet seq falls in this range [900, WINSIZE], it's temp

sleeptime = [0, 0.1/1000, 0.2/1000, 0.3/1000, 0.4/1000, 0.5/1000, 
             0.6/1000, 0.7/1000, 0.8/1000, 0.9/1000, 1.0/1000]  # hard coded

currentbitrate = [0]    # global variable that controls sleeping time
recentobservedRTTs = {} # record the most recent RTTWIN RTTs for each rate
lostseq = {}            # record the lost packet sequence for each rate
ratefailed = {}         # record if a rate has failed in the past 10 sec
temppacketset = [0]      # global variable that indicates temp packets rate already set

for rate in sleeptime:  
  # initialize data struct for link stats
  recentobservedRTTs[rate] = []  
  lostseq[rate] = []
  ratefailed[rate] = [False, None]
    
listlock = createlock() # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.196.236', 63101)  # this needs to be phone's IP

log("my IP: " + localip + '\n')

main()
############ end of main() ############ 

