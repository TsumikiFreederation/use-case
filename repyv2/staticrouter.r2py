#
# IB: Refactor the repyv2/; particularly move this file out of the repyv2/ directory.
#

"""
<Program Name>
  staticrouter.r2py

<Started>
  Aug 15, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

dy_import_module_symbols("outstandingseq.r2py")
dy_import_module_symbols("routercommon.r2py") 
                  

def updatestats(rate, seq, now, packetsequence):
  """
  Update link statistics everytime we receive a packet.
  """ 
  if int(seq) in packetsequence:
    sendtime = packetsequence[int(seq)]
    newrtt = now - sendtime  # transmission time
    stats[rate].append((seq, sendtime, newrtt))
    
    try:  # delete seq upon ack
      del packetsequence[int(seq)] 
    except KeyError:
      log(seq + "th not in the sequence (already timeout?).\n")
      pass

  else:
    log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n") 
    pass

  
def resetstats(now, packetsequence, outstandingseq):
  """
  Reset link statistics every CYCLE sec (remove info older than
  CYCLE sec).
  """
  oldseq = []
  for (id, (rate, sendtime)) in packetsequence.items():
    if sendtime < (now - CYCLE):
      oldseq.append(id)

  if oldseq != []:
    seqlimit = max(oldseq)  # find the largest seq in lostseq
    numlost = findlessthan(outstandingseq, seqlimit)  
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # packets older than 2RTT (seq's smaller than seqlimit in 
    # outstandingseq) are considered lost: remove them all 
    removelessthan(outstandingseq, seqlimit)

def myfunc(l):
    r = []
    p = q = None
    for x in l + [-1]:
        if x - 1 == q:
            q += 1
        else:
            if p:
               if q > p:
                   r.append('%s-%s' % (p, q))
               else:
                   r.append(str(p))
            p = q = x
    return '(%s)' % ', '.join(r)


def existconsequtivelosses(lostseq, rate, n):
  """
  Find if there are n consequtive losses when using rate.
  """
  loss = lostseq[rate]

  if loss == []:
    return False

  left = right = None
  for x in loss + [-1]:
    if x - 1 == right:
      right += 1
    else:
      if left:
        if right - left >= n-1:
          log('[' + str(left) + '-' + str(right) + ']\n')
          return True
      left = right = x
      
  return False

      
def selectpermrate(n, m):
  """
  Select the highest rate without n successive failures 
  in the past m sec.
  """
  return


def selecttemprate(n, currentrate):
  """
  Select a random rate that (1) has not failed n successive 
  times and (2) have a minimum transmission time lower than 
  the currentrate's average transmission time.
  """
  return


def selectlowesttxtime():
  """
  Select a rate that has the lowest average tx time.
  """
  return

  
def ispermanent(seq):
  """
  Return if a packet seq # is permanent or not.
  """
  # IB: need better comment: "permanent" is an undefined keyword.
  if seq % WINSIZE in PERMWIN:
    return 1
  elif seq % WINSIZE in TEMPWIN:
    return 0
  else: 
    log("something went wrong when checking packet ispermanent...\n")
    


def samplerate(now, lostseq, rate):
  """
  Given lost packets, adjust sending rate. 
  """
  selected = None
  
  if existconsequtivelosses(lostseq, rate, 4) == True:
    candidate = []
    for t in sleeptime:
      if t!= rate and existconsequtivelosses(lostseq, t, 4) == False:
        candidate.append(t)
    selected = min(candidate)

  if selected != None:
    currentbitrate[0] = selected
    log("current sleep time: " + str(currentbitrate[0]) + '\n\n')
  

def checkloss(now, RTT, packetsequence, outstandingseq, lostseq):
  """
  Every 2*RTT check pkt loss, delete outdated packets.
  """

  for (id, (rate, sendtime)) in packetsequence.items():
    if sendtime < (now - 2*RTT):
      # if a packet was sent more than 2*RTT ago, it's considered lost
      lostseq[rate].append(id)   #lostseq[rate].append((id, sendtime))

  samplerate(now, lostseq, rate)
  
  if lostseq[rate] != []:
    seqlimit = max(lostseq[rate])  # find the largest seq in lostseq
    numlost = findlessthan(outstandingseq, seqlimit)  
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # packets older than 2RTT (seq's smaller than seqlimit in 
    # outstandingseq) are considered lost: remove them all 
    removelessthan(outstandingseq, seqlimit)
    lostseq[rate] = []
    
  else:
    logifdebug(DEBUG, "num lost (packets older than 2RTT): None\n\n")
      
    
def recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, outstandingseq):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        # if there is SocketWouldBlockError, the rest will be skipped
        
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        listlock.acquire(True)
        delfromoutstandingseq(int(seq), outstandingseq)
        listlock.release()
      
        if int(seq) in packetsequence:
          rate, sendtime = packetsequence[int(seq)]
          
          try:  # delete seq upon ack
            del packetsequence[int(seq)]           
          except KeyError:
            raise RangeException("Packet seq not found", 
              [str(seq) + " is not in packetsequence: " + str(packetsequence)]) 

          newrtt = now - sendtime  # update RTT
          recentobservedRTTs[rate].append(newrtt)
          if len(recentobservedRTTs[rate]) > RTTWIN: # only keep RTTWIN most recent RTTs
            recentobservedRTTs[rate].pop(0)
            
        else:
          raise RangeException("Packet seq not found", 
              [str(seq) + " is not in packetsequence: " + str(packetsequence)])               

      except SocketWouldBlockError:
        pass

  return ack


def sendpackets(sequenceno, packetsequence, outstandingseq):
  """
  Sends packets to the receiver.
  """
  # following variables are for calculating throughput
  totalbits = 0   # record total bytes received
  totaltime = 0
  throughput = 0                 # initial rate is 0
  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True:     
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    timestamp = getruntime()  # record (seq, sendtime)
    packetsequence[sequenceno] = (currentbitrate[0], timestamp)
    #log("packetsequence: " + str(packetsequence) + '\n')
      
    listlock.acquire(True)
    addtooutstandingseq(sequenceno, outstandingseq)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)
    #log("outstandingseq: " + str(outstandingseq) + '\n')

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp

    # based on recently observed RTTs, find/check/remove packets older than 2RTT
    if recentobservedRTTs[currentbitrate[0]] != []:
      RTT = estimateRTT(recentobservedRTTs[currentbitrate[0]])
      if oldestpktsendtime != [] and (timestamp - oldestpktsendtime[0]) > 2*RTT:
        listlock.acquire(True)
        checkloss(timestamp, RTT, packetsequence, outstandingseq, lostseq)
        listlock.release()
        del oldestpktsendtime[0:len(oldestpktsendtime)]
    
    sleep(currentbitrate[0])  # sleep for currentbitrate sec
    if sequenceno % 1000 == 0:
      logifdebug(DEBUG, "sleeping for " + str(currentbitrate[0]) + "sec\n")
      
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      #log("sleep time " + str(currentbitrate[0]) + "sec, send rate " 
      #    + str(throughput) + " Mbps\n")
      totalbits = 0  # reset bits
      resetstats(currenttime, packetsequence, outstandingseq)

    sequenceno = sequenceno + 1
  

def main():
  """
  The main funciton.
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1
  outstandingseq = []    # record outstanding packets
  packetsequence = {} 

  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, outstandingseq))

  sendpackets(sequenceno, packetsequence, outstandingseq)


############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
DEBUG = 0     # output some debug messages if DEBUG == 1 
CYCLE = 10    # time duration in seconds to delete old data entries
RTTWIN = 30     # keep the most recent for RTTWIN packets
WINSIZE = 1000
PERMWIN = range(0, 900)  # when seq%WINSIZE falls in this rage, the packet is permanent
TEMPWIN = range(900, WINSIZE)

sleeptime = [0, 0.1/1000, 0.2/1000, 0.3/1000, 0.4/1000, 0.5/1000, 
             0.6/1000, 0.7/1000, 0.8/1000, 0.9/1000, 1/1000]  # hard coded

currentbitrate = [0]    # global variable that controls sleeping time
recentobservedRTTs = {}
lostseq = {}

for rate in sleeptime:  
  # initialize data struct for link stats: each 'rate' entry
  # is a list [(seq, sendtime, rtt), (seq, sendtime, rtt), ...]
  recentobservedRTTs[rate] = []  
  lostseq[rate] = []
    
listlock = createlock() # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.192.157', 63101)  # this needs to be phone's IP

log("my IP: " + localip + '\n')

main()
############ end of main() ############ 

