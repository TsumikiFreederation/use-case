"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  return max(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 


def rangeinsert(first, second, seqrange, index):
  """
  Depending on the values of first, second, 
  insert the correct range in seqrange at index.
  """
  if first == second:
    seqrange.insert(index, [first])
  else:
    seqrange.insert(index, [first, second])
              

def delfromseqrange(seq, seqrange):
  """
  Delete seq from the sequence range. Add new range if necessary.
  """
  for subrange in seqrange:      
    index = seqrange.index(subrange)

    if len(subrange) == 1:
        if seq == subrange[0]:
          seqrange.remove(subrange)  
    else:
      left, right = subrange 
      if right >= seq:
        seqrange.remove(subrange)        
        if right == seq:  # change to [left, right-1] 
          rangeinsert(left, right-1, seqrange, index)
          
        else: # right > seq
          if left == seq:  # change to [left+1, right]
            rangeinsert(left+1, right, seqrange, index)
          else: # left < seq < right: 
                # change to [left, seq-1], [seq+1, right]
            rangeinsert(left, seq-1, seqrange, index)
            rangeinsert(seq+1, right, seqrange, index+1)
              
        break
            
      else: # none of the above cases
        continue

      

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, seqrange):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        recvtime = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        logifdebug(DEBUG, "received " + seq + "th packet at " + str(recvtime))
        delfromseqrange(int(seq), seqrange)
        logifdebug(DEBUG, str(seqrange))
             
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          # delete seq upon ack
          try:
            del packetsequence[int(seq)]           
            # if del throws KeyError, the rest from here in the try block will be skipped
            rtt = recvtime - sendtime
            logifdebug(DEBUG, seq + "th pkt received. send time: " + str(sendtime) + 
                "  receive time: " + str(recvtime) + "  rtt: " + str(rtt) 
                + ". seq queue: " + str(packetsequence) + ", outstanding " + str(seqrange)) 

            # update RTT
            recentobservedRTTs.append(rtt)
            if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
              recentobservedRTTs.pop(0)

            logifdebug(DEBUG, "recentobservedRTTs: " + str(recentobservedRTTs) + "\n")
              
          except KeyError:
            # at this point, checkRTT thread could delete this packet
            log(seq + "th not in the sequence (already timeout?).\n")
            pass
            
        else:
          log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n")                

      except SocketWouldBlockError:
        pass

  return ack


def expiresentpackets(recentobservedRTTs, packetsequence):
  """
  A closure that checks if a packet in packetsequence has
  timed out.
  """
  
  def rtt():
    """
    Inside of the closure
    """
  
    while True:
      if len(recentobservedRTTs) < RTTWIN: # need at least RTTWIN pkts
        continue 

      delseq = []
      updatedRTT = estimateRTT(recentobservedRTTs)
      for (id, sendtime) in packetsequence.items():
        if sendtime < getruntime() - updatedRTT*2:
          # if a packet was sent more than twice 
          # RTT ago, then it's considered timed out
          logifdebug(DEBUG, str(id) + "th packet too old...need to delete")
          delseq.append(id)

      for i in delseq:
        try:
          del packetsequence[i]
        except KeyError:
          # at this point, previously recorded id could already  
          # be deleted by the recvack thread
          log(str(i) + "th not in the sequence (already received?).\n")
          pass

      logifdebug(DEBUG, "after checkRTT, sequence: " + str(packetsequence))

      sleep(updatedRTT*2)

  return rtt


def checkloss(seqrange):
  """
  When reaches WIN, check pkt loss
  """
  log("after sending " + str(WIN) + " packets, lost seq: " + str(seqrange) + '\n')


def main():
  """
  The main funciton..
  """

  (localip, localport) = (getmyip(), 63100)
  (destip, destport) = ('206.12.54.53', 63101)  # TODO: this needs to be phone's IP
  log("my IP: " + localip + '\n')

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)
  seqrange = [[1, WIN]]   # record sent/outstanding packets
  sequenceno = 1   # sequence number of packets, starting from 1 to WIN
  
  # initial variables
  packetsequence = {}
  recentobservedRTTs = []  # initially set to a large value
  totalbits = 0   # record total bytes received
  totaltime = 0

  sendtotal = 0   # time to send WIN packets

  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, seqrange))

  # thread that checks if a packet in packetsequence has timed out.
  createthread(expiresentpackets(recentobservedRTTs, packetsequence))

  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True: 
    
    starttime = getruntime()  # record time before sending WIN packets
    
    while sequenceno <= WIN:
      # router sends a bunch of packets to the client
      packet = str(sequenceno) + "|" + '0'*LENGTH 
      packetsequence[sequenceno] = getruntime()  # record (seq, sendtime)

      sendmessage(destip, destport, str(packet), localip, localport)
      
      totalbits = totalbits + len(packet)*8
      currenttime = getruntime()
      totaltime = currenttime - lastchecktime
      if totaltime > CYCLE:
        # check throughput and movement every CYCLE sec
        lastchecktime = currenttime # reset clock
        throughput = float(totalbits)/(totaltime)/1000000 
        log("send rate: " + str(throughput) + " Mbps\n\n")
        totalbits = 0  # reset bits

      sequenceno = sequenceno + 1

    endtime = getruntime()  # record time after sending WIN packets

    logifdebug(1, "it took " + str(endtime-starttime) + " to send " + str(WIN)
             + " pkts of " + str(LENGTH) + "bytes")
    sendtotal = 0

    if recentobservedRTTs != []:
      sleep(estimateRTT(recentobservedRTTs))
    
    #checkloss(seqrange)  # when reaches WIN, check pkt loss

    del seqrange[0:len(seqrange)]  # reset sequence window and number      
    seqrange.append([1, WIN])  

    #packetsequence.clear()     # reset packet sequence 
    sequenceno = 1


    
############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
RTTWIN = 10      # check packet loss every RTTWIN ack
WIN = 1000        # window size to check for packet loss
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
CYCLE = 1  # time duration to calculate throughput

main()
