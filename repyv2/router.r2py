"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

from repyportability import *
import cProfile, pstats, StringIO


def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  return max(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 


def rangeinsert(first, second, seqrange, index):
  """
  Depending on the values of first, second, 
  insert the correct range in seqrange at index.
  """
  if index == len(seqrange):
    seqrange.append([])
    
  if first == second:
    #seqrange.insert(index, [first])
    seqrange[index] = [first]
  else:
    #seqrange.insert(index, [first, second])
    seqrange[index] = [first, second]
              

def delfromseqrange(seq, seqrange):
  """
  Delete seq from the sequence range. Add new range if necessary.
  """
  
  for subrange in seqrange:      
    index = seqrange.index(subrange)
    #log(str(index) + ": " + str(subrange) + "\n")

    if len(subrange) == 1:
      if seq == subrange[0]:
        seqrange.remove(subrange)  
    else:
      left, right = subrange 
      if right >= seq:
        #seqrange.remove(subrange)        
        if right == seq:  # change to [left, right-1] 
          rangeinsert(left, right-1, seqrange, index)         
        else: # right > seq
          if left == seq:  # change to [left+1, right]
            rangeinsert(left+1, right, seqrange, index)
          else: # left < seq < right: 
                # change to [left, seq-1], [seq+1, right]
            rangeinsert(left, seq-1, seqrange, index)
            rangeinsert(seq+1, right, seqrange, index+1)
              
        break
            
      else: # none of the above cases
        continue


def addtoseqrange(seq, seqrange):
  """
  Add seq to the sequence range. 
  """
 
  if seqrange == []:
    seqrange.append([seq])
  else:      
    for subrange in seqrange[::-1]:         
      index = seqrange.index(subrange)

      if len(subrange) == 1:  
        right = subrange[0]
        left = right
      else: # len(subrange) == 2
        left, right = subrange 

      if right > seq:  # this case shouldn't exist: send 12 before 11
        continue        

      if right < seq - 1:  # [[1,3], [5,7], [10]]: now send seq 12
        seqrange.append([seq])   # [[1,3], [5,7], [10], [12]]
      elif right == seq - 1:  # [[1,3], [5,7], [10]]: now send seq 11
        #seqrange.remove(subrange)
        #seqrange.append([left, seq])  # [[1,3], [5,7], [10,11]]
        seqrange[index] = [left, seq]

      break
    

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, seqrange):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:
      pr = cProfile.Profile()
      pr.enable()
      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        logifdebug(DEBUG, "received " + seq + "th packet at " + str(now))
        listlock.acquire(True)
        delfromseqrange(int(seq), seqrange)
        listlock.release()
        logifdebug(DEBUG, "while receive, " + str(seqrange) + '\t' + str(packetsequence))
      
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          # delete seq upon ack
          try:
            del packetsequence[int(seq)]           
            # if del throws KeyError, the rest from here in the try block will be skipped
            #logifdebug(1, str(seqrange) + '\t' + str(packetsequence))
            newrtt = now - sendtime
            #logifdebug(DEBUG, seq + "th pkt received. send time: " + str(sendtime) + 
            #    "  receive time: " + str(now) + "  rtt: " + str(newrtt) 
            #    + ". seq queue: " + str(packetsequence) + ", outstanding " + str(seqrange)) 

            # update RTT
            recentobservedRTTs.append(newrtt)
            if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
              recentobservedRTTs.pop(0)

            logifdebug(DEBUG, "recentobservedRTTs: " + str(recentobservedRTTs) + "\n")
            if recentobservedRTTs != []:
              RTT = estimateRTT(recentobservedRTTs)

            if oldestpktsendtime != [] and now - oldestpktsendtime[0] > 2*RTT:
              logifdebug(DEBUG, "now: " + str(now) + ", oldestpktsendtime: " + str(oldestpktsendtime) + ", 2*RTT: " + str(2*RTT) + '\n')
              #listlock.acquire(True)
              checkloss(now, RTT, recentobservedRTTs, packetsequence, seqrange)
              #listlock.release()
              del oldestpktsendtime[0:len(oldestpktsendtime)]
              
          except KeyError:
            # at this point, checkRTT thread could delete this packet
            log(seq + "th not in the sequence (already timeout?).\n")
            pass
            
        else:
          #log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n") 
          pass               

      except SocketWouldBlockError:
        pass
        #sleep(0.000001)

      pr.disable()
      s = StringIO.StringIO()
      sortby = 'cumulative'
      ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
      ps.print_stats()
      print s.getvalue()

  return ack



def findlessthan(seqrange, seqlimit):
  """
  Find in seqrange all the seq numbers that are less than seqlimit.
  """
  lostseq = []

  for subrange in seqrange:
    if len(subrange) == 1:
      left = subrange[0]
      if left <= seqlimit:
        lostseq.append(left)
    else:  # len(subrange) == 2
      left, right = subrange
      for num in range(left, right+1):
        if num <= seqlimit:
          lostseq.append(num)

  return lostseq



def checkloss(now, RTT, recentobservedRTTs, packetsequence, seqrange):
  """
  When reaches WIN, check pkt loss
  """
  logifdebug(DEBUG, "at " + str(now) + ", with rtt " + str(RTT) + "s, seqrange (outstanding seq): " + str(seqrange) + '\n')
  logifdebug(DEBUG, "recentobservedRTTs: " + str(recentobservedRTTs) + "\n")

  oldseq = []
  for (id, sendtime) in packetsequence.items():
    if sendtime < now - RTT*2:
      # if a packet was sent more than 2*RTT ago, it's considered lost
      oldseq.append(id)

  #log("packets older than " + str(now - RTT*2) + ': ' + str(oldseq) + '\n')

  if oldseq != []:
    seqlimit = oldseq[-1]  # last/largest seq in lostseq
    numlost = findlessthan(seqrange, seqlimit)  

    if numlost != []:
      logifdebug(DEBUG, "num lost (packets older than 2RTT): " + str(numlost) + '\n\n')
      # TODO: adjust rate      
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # Remove all seq's smaller than seqlimit from seqrange
    for subrange in seqrange:      
      index = seqrange.index(subrange)
      if len(subrange) == 1:
        right = subrange[0]
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)  
      else:  # len(subrange) == 2
        left, right = subrange 
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)
        else:  # right > seqlimit
          if left <= seqlimit:  # left <= seqlimit < right
            rangeinsert(seqlimit+1, right, seqrange, index)

    emptyindex = []
    for subrange in seqrange: 
      if subrange == []:
        emptyindex.append(seqrange.index(subrange))

    for index in emptyindex:
      del seqrange[index]

    #logifdebug(1, "seqlimit:" + str(seqlimit) + " updated seqrange: " + 
    #  str(seqrange) + '\tpacketsequence: ' + str(packetsequence) + '\n')
    
  else:
      logifdebug(DEBUG, "num lost (packets older than 2RTT): None\n\n")


def sendpackets(sequenceno, packetsequence, seqrange):
  """
  Sends packets to the receiver.
  """
  totalbits = 0   # record total bytes received
  totaltime = 0
  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True: 
    
    #starttime = getruntime()  # record time before sending WIN packets
    
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    #if sequenceno % N == 0:
    timestamp = getruntime()  # record (seq, sendtime)
    packetsequence[sequenceno] = timestamp

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp
      logifdebug(DEBUG, "oldestpktsendtime:" + str(oldestpktsendtime) + '\n')
      
    #logifdebug(DEBUG, "sending " + str(sequenceno) + "th packet at " + str(timestamp))
    listlock.acquire(True)
    addtoseqrange(sequenceno, seqrange)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)
    #logifdebug(DEBUG, "while send, " + str(seqrange) + '\t' + str(packetsequence))
      
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      log("send rate: " + str(throughput) + " Mbps\n\n")
      #log("packetsequence: " + str(len(packetsequence)) + '\n')
      #log("seqrange: " + str(len(seqrange)) + '\n')
      totalbits = 0  # reset bits

    sequenceno = sequenceno + 1
      
    #endtime = getruntime()  # record time after sending WIN packets

    #logifdebug(DEBUG, "it took " + str(endtime-starttime) + " to send " + str(WIN)
    #         + " pkts of " + str(LENGTH) + "bytes")
    #sendtotal = 0

    #if recentobservedRTTs != []:
    #  sleeptime = estimateRTT(recentobservedRTTs)
    #  log("sleeping " + str(sleeptime) + 'ms.\n')
    #  sleep(sleeptime)

    #if sequenceno % WIN == 0:        ####### beta!!!!!!!
    #  del seqrange[0:len(seqrange)]  # reset sequence window and number        
    #  packetsequence.clear()     # reset packet sequence 
    #  sequenceno = 1


def main():
  """
  The main funciton..
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1 to WIN
  seqrange = []   # record outstanding packets
  packetsequence = {}
  recentobservedRTTs = []  # initially set to a large value
  #sendtotal = 0   # time to send WIN packets

  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, seqrange))
 
  sendpackets(sequenceno, packetsequence, seqrange)



############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
RTTWIN = 10      # check packet loss every RTTWIN ack
WIN = 1000        # window size to check for packet loss
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
N = 10      # timestamp packets every Nth
CYCLE = 1  # time duration to calculate throughput

listlock = createlock() # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.192.157', 63101)  # TODO: this needs to be phone's IP
log("my IP: " + localip + '\n')
      
main()
#cProfile.run('main()')
############ end of main() ############ 

