"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

#from repyportability import *


def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  #return max(recentobservedRTTs)
  return sum(recentobservedRTTs)/len(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 


def rangeinsert(first, second, seqrange, index):
  """
  Depending on the values of first, second, 
  insert the correct range in seqrange at index.
  """
  if index == len(seqrange):
    seqrange.append([])
    
  if first == second:
    seqrange[index] = [first]
  else:
    seqrange[index] = [first, second]
              

def delfromseqrange(seq, seqrange):
  """
  Delete seq from the sequence range. Add new range if necessary.
  """
  
  for subrange in seqrange:      
    index = seqrange.index(subrange)

    if len(subrange) == 1:
      if seq == subrange[0]:
        seqrange.remove(subrange)  
    else:
      left, right = subrange 
      if right >= seq:
        if right == seq:  # change to [left, right-1] 
          rangeinsert(left, right-1, seqrange, index)         
        else: # right > seq
          if left == seq:  # change to [left+1, right]
            rangeinsert(left+1, right, seqrange, index)
          else: # left < seq < right: 
                # change to [left, seq-1], [seq+1, right]
            rangeinsert(left, seq-1, seqrange, index)
            rangeinsert(seq+1, right, seqrange, index+1)
              
        break
            
      else: # none of the above cases
        continue


def addtoseqrange(seq, seqrange):
  """
  Add seq to the sequence range. 
  """
 
  if seqrange == []:
    seqrange.append([seq])
  else:      
    for subrange in seqrange[::-1]:         
      index = seqrange.index(subrange)

      if len(subrange) == 1:  
        right = subrange[0]
        left = right
      else: # len(subrange) == 2
        left, right = subrange 

      if right > seq:  # this case shouldn't exist: send 12 before 11
        continue        

      if right < seq - 1:  # [[1,3], [5,7], [10]]: now send seq 12
        seqrange.append([seq])   # [[1,3], [5,7], [10], [12]]
      elif right == seq - 1:  # [[1,3], [5,7], [10]]: now send seq 11
        seqrange[index] = [left, seq]

      break
    

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, seqrange):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        # if there is SocketWouldBlockError, the rest will be skipped
        
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        listlock.acquire(True)
        delfromseqrange(int(seq), seqrange)
        listlock.release()
      
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          
          try:  # delete seq upon ack
            del packetsequence[int(seq)]           
          except KeyError:
            log(seq + "th not in the sequence (already timeout?).\n")
            pass

          newrtt = now - sendtime  # update RTT
          recentobservedRTTs.append(newrtt)
          if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
            recentobservedRTTs.pop(0)
            
        else:
          log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n") 
          pass               

      except SocketWouldBlockError:
        pass

  return ack



def findlessthan(seqrange, seqlimit):
  """
  Find in seqrange all the seq numbers that are less than seqlimit.
  """
  lostseq = []

  for subrange in seqrange:
    if len(subrange) == 1:
      left = subrange[0]
      if left <= seqlimit:
        lostseq.append(left)
    else:  # len(subrange) == 2
      left, right = subrange
      for num in range(left, right+1):
        if num <= seqlimit:
          lostseq.append(num)

  return lostseq


def rateadjust(now, numlost, packetsequence):
  """
  Given lost packets, adjust sending rate. 
  """
  log(str(id(zzz))+'\n')
  log(str(id(ratesample))+'\n')

  oldbr = zzz[0]
  br = 0
  
  if numlost != []: # loss happened, slow down 
    for num in numlost:
      if int(num) in packetsequence:
        sendtime = packetsequence[int(num)]
        failedTime[zzz[0]] = now 
        if ratesample[0] == 1:
          br = oldbr
        else:
          br = min(zzz[0]+0.01/1000, max(sleeptime)) # 0.01: arbitrary number?
          ratesample = 0              
  else: # no loss, speed up
    ratesample[0] = 0
    if now - pickedTime[zzz[0]] > 0.05:
      for tau in sleeptime:
        if now - failedTime[tau] > 0.1:
          br = tau
          break           
      ratesample[0] = 1
      oldbr = br
    else:
      br = zzz[0]

    if br != zzz[0]:
      pickedTime[br] = now
      
  zzz[0] = br

  
    
def checkloss(now, RTT, packetsequence, seqrange):
  """
  Every 2*RTT check pkt loss, delete outdated packets.
  """
  
  oldseq = []
  for (id, sendtime) in packetsequence.items():
    if sendtime < now - RTT*2:
      # if a packet was sent more than 2*RTT ago, it's considered lost
      oldseq.append(id)

  if oldseq != []:
    seqlimit = max(oldseq)  # last/largest seq in lostseq
    numlost = findlessthan(seqrange, seqlimit)  
    #rateadjust(now, numlost, packetsequence)
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # Remove all seq's smaller than seqlimit from seqrange
    for subrange in seqrange:      
      index = seqrange.index(subrange)
      if len(subrange) == 1:
        right = subrange[0]
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)  
      else:  # len(subrange) == 2
        left, right = subrange 
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)
        else:  # right > seqlimit
          if left <= seqlimit:  # left <= seqlimit < right
            rangeinsert(seqlimit+1, right, seqrange, index)

    emptyindex = []
    for subrange in seqrange: 
      if subrange == []:
        emptyindex.append(seqrange.index(subrange))

    for index in emptyindex:
      del seqrange[index]
    
  else:
      logifdebug(DEBUG, "num lost (packets older than 2RTT): None\n\n")

      

def sendpackets(sequenceno, packetsequence, seqrange):
  """
  Sends packets to the receiver.
  """
  totalbits = 0   # record total bytes received
  totaltime = 0
  throughput = 0       # initial rate is 0
  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True:     
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    timestamp = getruntime()  # record (seq, sendtime)
    packetsequence[sequenceno] = timestamp
      
    listlock.acquire(True)
    addtoseqrange(sequenceno, seqrange)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp

    if recentobservedRTTs != []:
      RTT = estimateRTT(recentobservedRTTs)
      if oldestpktsendtime != [] and timestamp - oldestpktsendtime[0] > 2*RTT:
        listlock.acquire(True)
        checkloss(timestamp, RTT, packetsequence, seqrange)
        listlock.release()
        del oldestpktsendtime[0:len(oldestpktsendtime)]
    
    #sleep(zzz[0])  # sleep for zzz ms
      
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      log("send rate: " + str(throughput) + " Mbps\n")
      totalbits = 0  # reset bits

    sequenceno = sequenceno + 1
  

def main():
  """
  The main funciton.
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1 to WIN
  seqrange = []    # record outstanding packets
  packetsequence = {}  # dict of (seq: sendtime)
  
  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, seqrange))

  sendpackets(sequenceno, packetsequence, seqrange)



############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
RTTWIN = 100     # keep the most recent RTTWIN RTTs
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
CYCLE = 1  # time duration to calculate throughput
recentobservedRTTs = []  # record the most recent RTTWIN RTTs
pickedTime = {}
failedTime = {}

sleeptime = [0, 0.1/1000, 0.2/1000, 0.3/1000, 0.4/1000, 0.5/1000, 
             0.6/1000, 0.7/1000, 0.8/1000, 0.9/1000, 1/1000]  # hard coded
zzz = [0]    # global variable that controls sleeping time!!
ratesample = [0] 


listlock = createlock()  # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.196.111', 63101)  # TODO: this needs to be phone's IP
log("my IP: " + localip + '\n')
      
main()
############ end of main() ############ 

