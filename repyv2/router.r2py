"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

############ define protocol parameters ############ 
LENGTH = 1000    # packet length (change for different tx rates)
RTTWIN = 10      # check packet loss every RTTWIN ack
WIN = 1000        # window size to check for sending rate
sequenceno = 1   # sequence number of packets, starting from 1 to WIN

DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg
CYCLE = 1  # time duration to calculate throughput


def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  return max(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 


def delfromseqrange(seq, seqrange):
  """
  Delete seq from the sequence range. Add new range if necessary.
  """
  for subrange in seqrange:
      
    index = seqrange.index(subrange)

    if len(subrange) == 1:
        if seq == subrange[0]:
          seqrange.remove(subrange)  
    else:
      left, right = subrange
 
      if right >= seq:
        seqrange.remove(subrange)
        
        if right == seq:  # change to [left, right-1]        
          if left == right-1:  # TODO: replace if..else with a func
            seqrange.insert(index, [left])
          else:
            seqrange.insert(index, [left, right-1])
          
        else: # right > seq
          if left == seq:  # change to [left+1, right]
            if left+1 == right:
              seqrange.insert(index, [left+1])
            else:
              seqrange.insert(index, [left+1, right])
          else: # left < seq < right: 
                # change to [left, seq-1], [seq+1, right]
            if left == seq-1:
              seqrange.insert(index, [left])
            else:
              seqrange.insert(index, [left, seq-1])

            if right == seq+1:
              seqrange.insert(index+1, [right])
            else:
              seqrange.insert(index+1, [seq+1, right])
              
        break
            
      else: # none of the above cases
        continue

      

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, seqrange):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        recvtime = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        log("received " + seq + "th packet.\n")
        delfromseqrange(int(seq), seqrange)
        log(str(seqrange) + '\n')
             
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          # delete seq upon ack
          try:
            del packetsequence[int(seq)]           
            # if del throws KeyError, the rest from here in the try block will be skipped
            rtt = recvtime - sendtime
            logifdebug(DEBUG, seq + "th pkt received. send time: " + str(sendtime) + 
                "  receive time: " + str(recvtime) + "  rtt: " + str(rtt) 
                + ". seq queue: " + str(packetsequence)) 

            # update RTT
            recentobservedRTTs.append(rtt)
            if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
              recentobservedRTTs.pop(0)

            logifdebug(DEBUG, "recentobservedRTTs: " + str(recentobservedRTTs) + "\n")
              
          except KeyError:
            # at this point, checkRTT thread could delete this packet
            log(seq + "th not in the sequence (already timeout?).\n")
            pass
            
        else:
          log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n")                

      except SocketWouldBlockError:
        pass

  return ack


def expiresentpackets(recentobservedRTTs, packetsequence):
  """
  A closure that checks if a packet in packetsequence has
  timed out.
  """
  
  def rtt():
    """
    Inside of the closure
    """
  
    while True:
      if len(recentobservedRTTs) < RTTWIN: # need at least RTTWIN pkts
        continue 

      delseq = []
      updatedRTT = estimateRTT(recentobservedRTTs)
      for (id, sendtime) in packetsequence.items():
        if sendtime < getruntime() - updatedRTT*2:
          # if a packet was sent more than twice 
          # RTT ago, then it's considered timed out
          logifdebug(DEBUG, str(id) + "th packet too old...need to delete")
          delseq.append(id)

      for i in delseq:
        try:
          del packetsequence[i]
        except KeyError:
          # at this point, previously recorded id could already  
          # be deleted by the recvack thread
          log(str(i) + "th not in the sequence (already received?).\n")
          pass

      logifdebug(DEBUG, "after checkRTT, sequence: " + str(packetsequence))

      sleep(updatedRTT*2)

  return rtt


def checkloss(seqrange):
  """
  When reaches WIN, check pkt loss
  """
  log("after WIN..." + str(seqrange) + '\n')
  

############ main program ############ 

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.193.197', 63101)  # TODO: this needs to be phone's IP
#(getmyip(), 63101) 

log("my IP: " + localip + '\n')

# router's socket for client's ack
routerlistensocket = listenformessage(localip, localport)
seqrange = [[1, WIN]]   # record sent/outstanding packets

# initial variables
starttime = getruntime()
packetsequence = {}
recentobservedRTTs = []  # initially set to a large value
totalbits = 0   # record total bytes received
totaltime = 0

# thread that receives ack from the receiver, removes it from 
# packetsequence, and update the recently observed RTT
createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, seqrange))

# thread that checks if a packet in packetsequence has timed out.
createthread(expiresentpackets(recentobservedRTTs, packetsequence))

lastchecktime = getruntime()   # record total time spent over a CYCLE 

while True: 
    
  while sequenceno <= WIN:
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    packetsequence[sequenceno] = getruntime()  # record (seq, sendtime)
  
    logifdebug(DEBUG, "sending " + str(sequenceno) + "th packet. sending sequence: " 
      + str(packetsequence))
  
    sendmessage(destip, destport, str(packet), localip, localport)
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      log("send rate: " + str(throughput) + " Mbps\n")
      totalbits = 0  # reset bits

    sequenceno = sequenceno + 1

  if recentobservedRTTs != []:
    sleep(estimateRTT(recentobservedRTTs))
    
  checkloss(seqrange)  # when reaches WIN, check pkt loss

  seqrange = [[1, WIN]]  # reset sequence window and number
  sequenceno = 1


