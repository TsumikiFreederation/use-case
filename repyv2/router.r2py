#
# IB: Refactor the repyv2/; particularly move this file out of the repyv2/ directory.
#

"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

dy_import_module_symbols("outstandingseq.r2py")


def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  #return max(recentobservedRTTs)
  return sum(recentobservedRTTs)/len(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 
    

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, outstandingseq):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        # if there is SocketWouldBlockError, the rest will be skipped
        
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        listlock.acquire(True)
        delfromoutstandingseq(int(seq), outstandingseq)
        listlock.release()
      
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          
          try:  # delete seq upon ack
            del packetsequence[int(seq)]           
          except KeyError:
            # IB: need comment to explain how this can happen --
            # because of a race condition in modifying packetsequence?
            # What other thread is modifying it?
            log(seq + "th not in the sequence (already timeout?).\n")
            pass

          newrtt = now - sendtime  # update RTT
          recentobservedRTTs.append(newrtt)
          if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
            recentobservedRTTs.pop(0)
            
        else:
          #log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n") 
          # TODO: check why this error happens
          #
          # IB: Throw an exception if this is a legitimate error that should not occur.
          pass               

      except SocketWouldBlockError:
        pass

  return ack


def adjustrate(now, numlost, packetsequence):
  """
  Given lost packets, adjust sending rate. 
  """
  # IB: explain in more detail how you adjust the rate. The code below
  # is not substitute for a high-level description. I can't understand
  # what's happening below.

  bitrate = 0
  
  if numlost != []: # loss happened, slow down 
    # TODO: numlost can have multiple seq
    # do we deal with them individually?
    failedTime[currentbitrate[0]] = now 
    if ratesample[0] == 1:
      bitrate = lastbitrate[0]
    else:
      bitrate = min(currentbitrate[0]+0.1/1000, 
                    max(sleeptime))  # 0.1/1000: step size of sleeptime
      ratesample[0] = 0              
  else: # no loss, speed up
    ratesample[0] = 0
    if now - pickedTime[currentbitrate[0]] > 0.005:
      for tau in sleeptime:
        if now - failedTime[tau] > 0.01:
          bitrate = tau
          break           
      ratesample[0] = 1
      lastbitrate[0] = br
    else:
      bitrate = currentbitrate[0]

  if bitrate != currentbitrate[0]:
    pickedTime[bitrate] = now
      
  currentbitrate[0] = bitrate

  
    
def checkloss(now, RTT, packetsequence, outstandingseq):
  """
  Every 2*RTT check pkt loss, delete outdated packets.
  """

  oldseq = []
  for (id, sendtime) in packetsequence.items():
    if sendtime < (now - RTT*2):
      # if a packet was sent more than 2*RTT ago, it's considered lost
      oldseq.append(id)

  if oldseq != []:
    seqlimit = max(oldseq)  # find the largest seq in lostseq
    numlost = findlessthan(outstandingseq, seqlimit)  
    adjustrate(now, numlost, packetsequence)
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # packets older than 2RTT (seq's smaller than seqlimit in outstandingseq) are 
    # considered lost: remove them all 
    for subrange in outstandingseq:      
      index = outstandingseq.index(subrange)
      if len(subrange) == 1:
        right = subrange[0]
        if right <= seqlimit:
          outstandingseq[index] = []  #outstandingseq.remove(subrange)  
      else:  # len(subrange) == 2
        left, right = subrange 
        if right <= seqlimit:
          outstandingseq[index] = []  #outstandingseq.remove(subrange)
        else:  # right > seqlimit
          if left <= seqlimit:  # left <= seqlimit < right
            rangeinsert(seqlimit+1, right, outstandingseq, index)

    emptyindex = []
    for subrange in outstandingseq: 
      if subrange == []:
        emptyindex.append(outstandingseq.index(subrange))

    for index in emptyindex:
      del outstandingseq[index]
    
  else:
      logifdebug(DEBUG, "num lost (packets older than 2RTT): None\n\n")

      

def sendpackets(sequenceno, packetsequence, outstandingseq):
  """
  Sends packets to the receiver.
  """
  # following variables are for calculating throughput
  totalbits = 0   # record total bytes received
  totaltime = 0
  throughput = 0                 # initial rate is 0
  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True:     
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    timestamp = getruntime()  # record (seq, sendtime)
    packetsequence[sequenceno] = timestamp
      
    listlock.acquire(True)
    addtooutstandingseq(sequenceno, outstandingseq)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp

    # based on recently observed RTTs, find/check/remove packets older than 2RTT
    if recentobservedRTTs != []:
      RTT = estimateRTT(recentobservedRTTs)
      if oldestpktsendtime != [] and (timestamp - oldestpktsendtime[0]) > 2*RTT:
        listlock.acquire(True)
        checkloss(timestamp, RTT, packetsequence, outstandingseq)
        listlock.release()
        del oldestpktsendtime[0:len(oldestpktsendtime)]
    
    sleep(currentbitrate[0])  # sleep for currentbitrate sec
    if sequenceno % 1000 == 0:
      logifdebug(DEBUG, "sleeping for " + str(currentbitrate[0]) + "sec\n")
      
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      log("sleep time " + str(currentbitrate[0]) + "sec, send rate " + str(throughput) + " Mbps\n")
      totalbits = 0  # reset bits

    sequenceno = sequenceno + 1
  

def main():
  """
  The main funciton.
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1 to WIN
  outstandingseq = []    # record outstanding packets
  packetsequence = {}  # dict of (seq: sendtime)
  
  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, outstandingseq))

  sendpackets(sequenceno, packetsequence, outstandingseq)



############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)
RTTWIN = 100     # keep the most recent for RTTWIN packets
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg

CYCLE = 1  # time duration in seconds to calculate throughput
recentobservedRTTs = []  # record the most recent RTTWIN RTTs
pickedTime = {}   # global variable recording the time when a rate was picked
failedTime = {}   # global variable recording the time when a rate failed

sleeptime = [0, 0.1/1000, 0.2/1000, 0.3/1000, 0.4/1000, 0.5/1000, 
             0.6/1000, 0.7/1000, 0.8/1000, 0.9/1000, 1.0/1000]  # hard coded

# Python only treats lists, tuples and dicts as global variables.
currentbitrate = [0]    # global variable that controls sleeping time
ratesample = [0]        # global variable indicating if we are sampling the rate
lastbitrate = []        # global variable recording the last rate we picked
lastbitrate.append(currentbitrate[0])

listlock = createlock()  # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.196.111', 63101)  # TODO: this needs to be phone's IP
log("my IP: " + localip + '\n')
      
main()
############ end of main() ############ 

