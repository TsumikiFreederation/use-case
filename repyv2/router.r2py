#
# IB: Refactor the repyv2/; particularly move this file out of the repyv2/ directory.
#

"""
<Program Name>
  router.r2py

<Started>
  July 24, 2014

<Author>
  Yanyan Zhuang

<Purpose>
  Router as the data sender, for the use case of rate adaptation.
"""

#from repyportability import *


def deserialize(message):      
  """
  Returns the sequence of the packet, and movement hint.
  """
  if "|" in message:
    seq, move = message.split("|")
  else:
    seq = message
    move = None
  return (seq, move)


def estimateRTT(recentobservedRTTs):
  """
  Returns the max value of recent RTTs
  """
  #return max(recentobservedRTTs)
  return sum(recentobservedRTTs)/len(recentobservedRTTs)


def logifdebug(DEBUG, string):
  """
  Prints out string if DEBUG == 1.
  """
  if DEBUG == 1:
    log(string + '\n')
  else: 
    return 

#
# IB: 1. Move all methods related to the seqrange data-structure into
# a different file.
#     2. Convert this data structure into a class so
# that there is a proper data abstraction, functions become methods.
#
def rangeinsert(first, second, seqrange, index):
  """
  Depending on the values of first, second, 
  insert the correct range in seqrange at index.
  """
  # IB: what do arguments first, second, and index represent?
  # is [first,second] a new range you are inserting? Is index where you are inserting them?

  if index == len(seqrange):
    seqrange.append([])
    
  if first == second:
    seqrange[index] = [first]
  else:
    seqrange[index] = [first, second]
              

# IB: I would like to see tests for these seqrange methods. They might
# be correct, but I can't tell and it's easier to check with unit-tests.
def delfromseqrange(seq, seqrange):
  """
  Delete seq from the sequence range. Add new range if necessary.
  """
  
  for subrange in seqrange:      
    index = seqrange.index(subrange)

    if len(subrange) == 1:
      if seq == subrange[0]:
        seqrange.remove(subrange)  
        # IB: Don't you want a "break" statement here?
    else:
      left, right = subrange 
      # IB: You don't need this next if statement -- instead, change the next else to be
      # "else if right > seq". This will improve code readibility.
      if right >= seq:
        if right == seq:  # change to [left, right-1] 
          rangeinsert(left, right-1, seqrange, index)         
          # IB: Don't you also need to remove the subrange from seqrange?
          # Or, will rangeinsert do that?
        else: # right > seq
          if left == seq:  # change to [left+1, right]
            rangeinsert(left+1, right, seqrange, index)
          else: # left < seq < right: change to [left, seq-1], [seq+1, right]
            # IB: Why is left < seq at this point?
            rangeinsert(left, seq-1, seqrange, index)
            rangeinsert(seq+1, right, seqrange, index+1)
        break
        
      # IB: Do not need the next two lines -- they seem to be no-ops to me.
      #
      else: # none of the above cases
        continue


def addtoseqrange(seq, seqrange):
  """
  Add seq to the sequence range. 
  """
 
  if seqrange == []:
    seqrange.append([seq])
  else:      
    for subrange in seqrange[::-1]:         
      index = seqrange.index(subrange)

      if len(subrange) == 1:  
        right = subrange[0]
        left = right
      else: # len(subrange) == 2
        left, right = subrange 

      # IB: throw an exception if this should not occur. Do not ignore errors.
      #
      if right > seq:  # this case shouldn't exist: send 12 before 11
        continue        

      if right < seq - 1:  # [[1,3], [5,7], [10]]: now send seq 12
        seqrange.append([seq])   # [[1,3], [5,7], [10], [12]]
      elif right == seq - 1:  # [[1,3], [5,7], [10]]: now send seq 11
        seqrange[index] = [left, seq]

      break
    

def recvack(routerlistensocket, packetsequence, recentobservedRTTs, seqrange):
  """
  A closure that receives ack from the receiver, removes it from 
  packetsequence, and update the recently observed RTT
  """
  
  def ack():      
    """
    Inside of the closure
    """

    while True:      
      try:
        # receive ack and movement hint from client
        remoteip, remoteport, message = routerlistensocket.getmessage()
        # if there is SocketWouldBlockError, the rest will be skipped
        
        now = getruntime()
        (seq, move) = deserialize(message)  # TODO: use movement info 

        listlock.acquire(True)
        delfromseqrange(int(seq), seqrange)
        listlock.release()
      
        if int(seq) in packetsequence:
          sendtime = packetsequence[int(seq)]
          
          try:  # delete seq upon ack
            del packetsequence[int(seq)]           
          except KeyError:
            # IB: need comment to explain how this can happen --
            # because of a race condition in modifying packetsequence?
            # What other thread is modifying it?
            log(seq + "th not in the sequence (already timeout?).\n")
            pass

          newrtt = now - sendtime  # update RTT
          recentobservedRTTs.append(newrtt)
          if len(recentobservedRTTs) > RTTWIN: # only keep RTTWIN most recent RTTs
            recentobservedRTTs.pop(0)
            
        else:
          #log(seq + "th pkt is received before sent, or has been deleted due to timeout.\n") 
          # TODO: check why this error happens
          #
          # IB: Throw an exception if this is a legitimate error that should not occur.
          pass               

      except SocketWouldBlockError:
        pass

  return ack



# IB: Keep seqrange methods together.
# 
def findlessthan(seqrange, seqlimit):
  """
  Find in seqrange all the seq numbers that are less than seqlimit.
  """
  # IB: rename lostseq to something more meaningful.
  lostseq = []

  for subrange in seqrange:
    if len(subrange) == 1:
      left = subrange[0]
      if left <= seqlimit:
        lostseq.append(left)
    else:  # len(subrange) == 2
      left, right = subrange
      for num in range(left, right+1):
        if num <= seqlimit:
          lostseq.append(num)

  # IB: since seqrange is sorted, it makes sense to return lostseq
  # above when you found an item in seqrange that is > seqlimit.

  return lostseq


def adjustrate(now, numlost, packetsequence):
  """
  Given lost packets, adjust sending rate. 
  """
  # IB: explain in more detail how you adjust the rate. The code below
  # is not substitute for a high-level description. I can't understand
  # what's happening below.

  # IB: rename br to something more meaningful.
  br = 0
  
  if numlost != []: # loss happened, slow down 
    # TODO: numlost can have multiple seq
    # do we deal with them individually?
    failedTime[zzz[0]] = now 
    if ratesample[0] == 1:
      br = oldbr[0]
    else:
      br = min(zzz[0]+0.1/1000, max(sleeptime)) # 0.1: step size of sleeptime
      ratesample[0] = 0              
  else: # no loss, speed up
    ratesample[0] = 0
    if now - pickedTime[zzz[0]] > 0.005:
      for tau in sleeptime:
        if now - failedTime[tau] > 0.01:
          br = tau
          break           
      ratesample[0] = 1
      oldbr[0] = br
    else:
      br = zzz[0]

  if br != zzz[0]:
    pickedTime[br] = now
      
  zzz[0] = br

  
    
def checkloss(now, RTT, packetsequence, seqrange):
  """
  Every 2*RTT check pkt loss, delete outdated packets.
  """

  # IB: "seqrange" arg needs a different name -- seqrange is a
  # data-structure, but what does it represent?

  oldseq = []
  for (id, sendtime) in packetsequence.items():
    if sendtime < (now - RTT*2):
      # if a packet was sent more than 2*RTT ago, it's considered lost
      oldseq.append(id)

  if oldseq != []:
    seqlimit = max(oldseq)  # find the largest seq in lostseq
    numlost = findlessthan(seqrange, seqlimit)  
    adjustrate(now, numlost, packetsequence)
    
    # Remove all numlost from packetsequence
    for seq in numlost:
      if int(seq) in packetsequence:
        try:
          del packetsequence[int(seq)]
        except KeyError:
          # possibily recvack got this seq's ack
          log(seq + "th not in the sequence (recvack got this seq's ack?).\n")
          pass

    # Remove all seq's smaller than seqlimit from seqrange
    # IB: Expand comment to explain _why_ you do this.

    for subrange in seqrange:      
      index = seqrange.index(subrange)
      if len(subrange) == 1:
        right = subrange[0]
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)  
      else:  # len(subrange) == 2
        left, right = subrange 
        if right <= seqlimit:
          seqrange[index] = []  #seqrange.remove(subrange)
        else:  # right > seqlimit
          if left <= seqlimit:  # left <= seqlimit < right
            rangeinsert(seqlimit+1, right, seqrange, index)

    emptyindex = []
    for subrange in seqrange: 
      if subrange == []:
        emptyindex.append(seqrange.index(subrange))

    for index in emptyindex:
      del seqrange[index]
    
  else:
      logifdebug(DEBUG, "num lost (packets older than 2RTT): None\n\n")

      

def sendpackets(sequenceno, packetsequence, seqrange):
  """
  Sends packets to the receiver.
  """
  # IB: bits or bytes? varname + comment inconsistency.
  totalbits = 0   # record total bytes received

  # IB: Add comment -- what is totaltime, what is it used for?
  totaltime = 0
  throughput = 0       # initial rate is 0
  lastchecktime = getruntime()   # record total time spent over a CYCLE 

  while True:     
    # router sends a bunch of packets to the client
    packet = str(sequenceno) + "|" + '0'*LENGTH 
    timestamp = getruntime()  # record (seq, sendtime)
    packetsequence[sequenceno] = timestamp
      
    listlock.acquire(True)
    addtoseqrange(sequenceno, seqrange)
    listlock.release()
    sendmessage(destip, destport, str(packet), localip, localport)

    if oldestpktsendtime == []:
      oldestpktsendtime.append([])
      oldestpktsendtime[0] = timestamp

    # IB: Add comment -- what does the code below do?
    if recentobservedRTTs != []:
      RTT = estimateRTT(recentobservedRTTs)
      if oldestpktsendtime != [] and (timestamp - oldestpktsendtime[0]) > 2*RTT:
        listlock.acquire(True)
        checkloss(timestamp, RTT, packetsequence, seqrange)
        listlock.release()
        del oldestpktsendtime[0:len(oldestpktsendtime)]
    
    sleep(zzz[0])  # sleep for zzz sec
    if sequenceno % 1000 == 0:
      logifdebug(DEBUG, "sleeping for " + str(zzz[0]) + "sec\n")
      
    totalbits = totalbits + len(packet)*8
    currenttime = getruntime()
    totaltime = currenttime - lastchecktime
    if totaltime > CYCLE:
      # check throughput and movement every CYCLE sec
      lastchecktime = currenttime # reset clock
      throughput = float(totalbits)/(totaltime)/1000000 
      log("sleep time " + str(zzz[0]) + "sec, send rate " + str(throughput) + " Mbps\n")
      totalbits = 0  # reset bits

    sequenceno = sequenceno + 1
  

def main():
  """
  The main funciton.
  """

  # router's socket for client's ack
  routerlistensocket = listenformessage(localip, localport)

  # initial variables
  sequenceno = 1   # sequence number of packets, starting from 1 to WIN
  seqrange = []    # record outstanding packets
  packetsequence = {}  # dict of (seq: sendtime)
  
  # thread that receives ack from the receiver, removes it from 
  # packetsequence, and update the recently observed RTT
  createthread(recvack(routerlistensocket, packetsequence, 
                     recentobservedRTTs, seqrange))

  sendpackets(sequenceno, packetsequence, seqrange)



############ define protocol parameters ############   
LENGTH = 1000    # packet length (change for different tx rates)

# IB: is this expressing # of packets, or # of bytes, or seconds, or what?
RTTWIN = 100     # keep the most recent RTTWIN RTTs
DEBUG = 0     # output some debug messages if DEBUG == 1 
              # TODO: make this a command line arg

# IB: in ms, in seconds, or packets?
CYCLE = 1  # time duration to calculate throughput
recentobservedRTTs = []  # record the most recent RTTWIN RTTs
pickedTime = {}   # global variable recording the time when a rate was picked
failedTime = {}   # global variable recording the time when a rate failed

sleeptime = [0, 0.1/1000, 0.2/1000, 0.3/1000, 0.4/1000, 0.5/1000, 
             0.6/1000, 0.7/1000, 0.8/1000, 0.9/1000, 1.0/1000]  # hard coded

# IB: rename zzz to something more meaningful. Also, this is an array,
# so you are maintaining multiple values?
zzz = [0]         # global variable that controls sleeping time

# IB: As above, this is an array -- why do you need it to be an array?
# Comment should explain that this is maintaining mutiple sampling rates?
ratesample = [0]  # global variable indicating if we are sampling the rate

# IB: rename oldbr to something more meaningful -- what is br?
oldbr = []        # global variable recording the last rate we picked
oldbr.append(zzz[0])

listlock = createlock()  # to sync data structure updates in different threads
oldestpktsendtime = []   # record the time when the oldest pkt was sent

(localip, localport) = (getmyip(), 63100)
(destip, destport) = ('206.87.196.111', 63101)  # TODO: this needs to be phone's IP
log("my IP: " + localip + '\n')
      
main()
############ end of main() ############ 

